### 归并排序
#### Date:2022/8/15

归并排序的思路也是分治的方法，详情见快速排序模板，
本模板主要思路也是双指针算法的应用，但是快排使用的是对撞指针，在归并排序中我们使用的是划分区间的指针模式，排序过程如下图所示：
![merge](https://user-images.githubusercontent.com/53635655/184581704-44b7856c-bd0e-43c8-a2d4-57c99b489422.gif)



归并模板：
```C++
void merge_sort(int q[],int l,int r)
{
	// 递归终止情况
    if (l >= r) return;
    // 1.分成子问题
    int mid = l + r >> 1;
    // 2.递归处理子问题
    merge_sort(q,l,mid),merge_sort(q,mid + 1,r);
    // 3.合并子问题
    int i = l,j = mid + 1;
    int k = 0;
    while (i <= mid && j <= r)
        if (q[i] < q[j]) temp[k ++ ] = q[i ++ ];
        else temp[k ++ ] = q[j ++ ];
        
    while (i <= mid) temp[k ++ ] = q[i ++ ];
    while (j <= r) temp[k ++ ] = q[j ++ ];
    
    for (i = l,j = 0; i <= r; i ++ ,j ++ ) q[i] = temp[j];
}

```
#### 特征问题：`temp`保存的是`q[l~mid],q[mid+1~r]`之中从小到大排序的所有数
证明：（第一个while循环）
循环不变式：`temp[0~k - 1]`保存上述两组数中从小到大排序的最小k个数
1.初始
 `k = 0,temp[0~k - 1]`为空，此时显然成立

2.保持
假设某轮开始之前循环不变式成立，若`q[i] <= q[j]`，则`temp[k] = q[i]`
其中，`q[i] <= q[i+1~mid],q[i] <= q[j] <= q[j+1 ~ k]`
∴`q[i]`是剩余数字中最小
当`q[i] > q[j]`时，同理可以得到`temp[k] = q[j]`是剩余数字中最小的一个
∴`temp[k]`是剩余数字中最小的一个
∴`k`自增后，下轮循环开始之前，`temp[0~k-1]`保存从小到大排序的最小`k`个数

3.终止
`i > mid或 j > r`
则`q[l~mid]以及q[mid+1~r]`其中一个数组的数均已经遍历
`temp[0~k-1]`保存从小到大的k个数



#### 边界分析
自我审问：为什么不用`mid - 1`作为分割线呢
即`merge_sort(q,l,mid - 1),merge_sort(q,mid,l)`
因为`mid = l + r >> 1是`向下取整的过程，`mid`有可能取到`l`数组只有两个数字时，造成无线划分
解决此问题：`mid`向上取整数即可：如下所示
```C++
void merge_sort(int q[],int l,int r)
{
	if (l >= r) return;
	int mid = l + r + 1 >> 1; // 此处向上取整
	merge_sort(q,l,mid - 1),merge_sort(q,mid,r);

	int k = 0,i = l,j = mid;
	while (i < mid %% j <= r)
		if (q[i] <= q[j]) temp[k ++ ] = q[i ++ ];
		else temp[k ++ ] = q[j ++ ];
	while (i < mid) temp[k ++ ] = q[i ++ ];
	while (j <= r) temp[k ++ ] = q[j ++ ];

	for (i = l,j = 0; i <= r; i ++, j ++ ) q[i] = temp[j];
}
```
为什么 用 mid 作为分隔线时不会造成无限划分呢
因为此时 mid 是向下取整的, merge_sort(q, l, mid ) 中的 mid 一定不会取到 r 值
∴ merge_sort(q, l, mid ) 不会无限划分

#### 时间复杂度  

O(nlogn)
在这里时间复杂度和快排是一致的，但是归并排序是稳定的，快排是不稳定的算法
其实学过数字信号处理的同学，在学习分治算法的过程中总想到FFT中的基2的分治算法计算实数乘法和加法次数的问题，其实也可以看作是类似的研究

#### 摊还分析

摊还分析是一种分析时间复杂度的方法

主要有三种:

聚合分析(记账法)
核方法
势能法
聚合分析(记账法)最符合直观感觉,

##### 聚合分析归并排序时间复杂度

归并排序属于分治法, 很容易写出递归式:

T(n)=2T(n/2)+f(n)
其中, 2T(n/2)是子问题的时间复杂度, f(n) 是合并子问题的时间复杂度

1.直观

直观上我们感觉 f(n)=O(n), 事实也正是如何, 因为每次 while 都会把一个元素添加到数组中, 一共有 n 个元素, 所以 while 循环的次数为 n , 时间复杂度为 O(n)

2.摊还分析的聚合分析

对于每次迭代中选出并添加到数组中的元素, 我们给它的摊还代价设为 1(记账为 1)

一个元素只能计费一次, 因为马上就被添加到数组中了

一共有 n 个元素, 所以摊还总代价为 n, 算法的时间复杂度为 O(n)

	摊还代价, 我们自己设定的一个理想代价, 只有一个要求: 总的摊还代价大于总的	实际代价, 所以总摊还代价是总实际代价的上界
	
	tips:实际代价, 实际操作的代价

3.计算归并排序的递归式

得到 f(n)=O(n) 后, 根据递推式的计算方法(代入法, 递归树法, 主方法)容易计算出 T(n)=O(nlogn), 即归并排序的时间复杂度为 O(nlogn)

