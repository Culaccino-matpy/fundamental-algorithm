## 差分

### Date:2022-8-22

差分以及前缀和其实是一对互为逆运算的方式

##### 差分数组：

首先给定原数组`a[N]`

`a[1],a[2],...,a[n];`

然后我们构造一个数组`b[N]`

`b[1],b[2],...,b[n];`

从而有`a[i] = b[1] + b[2] + ... + b[i];`

也就是说，`a`数组是`b`数组的前缀和数组，反过来我们把b数组叫做a数组的差分数组。换句话说，每一个`a[i]`都是`b`数组中从头开始的一段区间和。

考虑如何构造差分`b`数组？

最为直接的方法

```C++
a[0 ]= 0;
b[1] = a[1] - a[0];
b[2] = a[2] - a[1];
b[3] =a [3] - a[2];
........
b[n] = a[n] - a[n-1];
```

我们只要有`b`数组，通过前缀和运算，就可以在*O(n)*的时间内得出a数组。



给定区间`[l ,r ]`，让我们把a数组中的`[ l, r]`中的每一个数都加上c,即 `a[l] + c , a[l+1] + c , a[l+2] + c ,,,,,, a[r] + c;`

暴力做法是for循环l到r区间，时间复杂度*O*(n)，如果我们需要对原数组执行m次这样的操作，时间复杂度就会变成*O(n*m)*。有没有更高效的做法吗? 考虑差分做法。

始终要记得，a数组是b数组的前缀和数组，比如对b数组的b[i]的修改，会影响到a数组中从a[i]及往后的每一个数。

首先让差分b数组中的` b[l] + c ,a`数组变成 `a[l] + c ,a[l+1] + c,,,,,, a[n] + c;`

然后我们打个补丁，`b[r+1] - c, a`数组变成 `a[r+1] - c,a[r+2] - c,,,,,,,a[n] - c;`

为啥还要打个补丁？

我们画个图理解一下这个公式的由来:

![差分](https://user-images.githubusercontent.com/53635655/188793796-6920f8ae-04b1-4216-b8f1-18b087d80199.png)


`b[l] + c`，效果使得`a`数组中 `a[l]`及以后的数都加上了`c`(红色部分)，但我们只要求l到r区间加上`c`, 因此还需要执行` b[r+1] - c`,让`a`数组中`a[r+1]`及往后的区间再减去`c`(绿色部分)，这样对于`a[r]` 以后区间的数相当于没有发生改变。

因此我们得出一维差分结论：给a数组中的`[ l, r]`区间中的每一个数都加上`c`,只需对差分数组`b`做 `b[l] + = c, b[r+1] - = c`。时间复杂度为*O(1)*, 大大提高了效率。

##### 二维差分

如果扩展到二维，我们需要让二维数组被选中的子矩阵中的每个元素的值加上`c`,是否也可以达到*O(1)*的时间复杂度。答案是可以的，考虑二维差分。

`a[][]`数组是`b[][]`数组的前缀和数组，那么`b[][]`是`a[][]`的差分数组

原数组： `a[i][j]`

我们去构造差分数组：` b[i][j]`

使得`a`数组中`a[i][j]`是`b`数组左上角`(1,1)`到右下角`(i,j)`所包围矩形元素的和。

如何构造b数组呢？

我们去逆向思考。

同一维差分，我们构造二维差分数组目的是为了 让原二维数组a中所选中子矩阵中的每一个元素加上`c`的操作，可以由*O(nn)*的时间复杂度优化成*O(1)*

已知原数组a中被选中的子矩阵为 以`(x1,y1)`为左上角，以`(x2,y2`)为右下角所围成的矩形区域;

始终要记得，`a`数组是`b`数组的前缀和数组，比如对b数组的b[i][j]的修改，会影响到`a`数组中从`a[i][j]`及往后的每一个数。

假定我们已经构造好了`b`数组，类比一维差分，我们执行以下操作
来使被选中的子矩阵中的每个元素的值加上`c`

```C++
b[x1][y1] + = c;

b[x1,][y2+1] - = c;

b[x2+1][y1] - = c;

b[x2+1][y2+1] + = c;
```

每次对b数组执行以上操作，等价于：

```C++
for(int i=x1;i<=x2;i++)
  for(int j=y1;j<=y2;j++)
    a[i][j]+=c;
```

画图进行理解：

![二维差分](https://user-images.githubusercontent.com/53635655/188793817-975f26c6-a4ce-437f-afad-ebaf879a1f9e.png)


`b[x1][ y1 ] +=c ;` 对应图1 ,让整个a数组中蓝色矩形面积的元素都加上了`c`。
`b[x1,][y2+1]-=c ; `对应图2 ,让整个a数组中绿色矩形面积的元素再减去`c`，使其内元素不发生改变。
`b[x2+1][y1]- =c ; `对应图3 ,让整个a数组中紫色矩形面积的元素再减去`c`，使其内元素不发生改变。
`b[x2+1][y2+1]+=c; `对应图4,,让整个a数组中红色矩形面积的元素再加上`c`，红色内的相当于被减了两次，再加上一次`c`，才能使其恢复。

![二维差分1](https://user-images.githubusercontent.com/53635655/188793837-b0e76e5e-8e78-4952-b626-0d916554540b.png)


###### 将上述过程封装为一个插入函数：

```C++
void insert(int x1,int y1,int x2,int y2,int c)
{     //对b数组执行插入操作，等价于对a数组中的(x1,y1)到(x2,y2)之间的元素都加上了c
    b[x1][y1]+=c;
    b[x2+1][y1]-=c;
    b[x1][y2+1]-=c;
    b[x2+1][y2+1]+=c;
}
```

